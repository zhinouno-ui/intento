<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hole City 3D - Update Jugable</title>
  <style>
    :root {
      --hud-bg: rgba(7, 10, 20, 0.82);
      --hud-border: rgba(180, 220, 255, 0.24);
      --accent: #57d7ff;
      --ok: #8affc2;
      --warn: #ffd873;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: Inter, Segoe UI, Arial, sans-serif;
      color: #eaf2ff;
      background: radial-gradient(circle at 20% 12%, #263e71, #0d1328 58%, #05070f 100%);
    }
    #game { position: fixed; inset: 0; }
    .hud {
      position: fixed;
      z-index: 20;
      background: var(--hud-bg);
      border: 1px solid var(--hud-border);
      border-radius: 12px;
      padding: 10px 13px;
      box-shadow: 0 12px 36px rgba(0,0,0,0.42);
      backdrop-filter: blur(7px);
      user-select: none;
    }
    #stats { top: 12px; left: 12px; min-width: 245px; }
    #controls { left: 12px; bottom: 12px; max-width: 330px; font-size: 13px; line-height: 1.35; }
    #objective { top: 12px; right: 12px; min-width: 240px; text-align: right; }
    #center {
      position: fixed;
      z-index: 30;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(5,10,22,0.9);
      border: 1px solid rgba(130, 204, 255, 0.3);
      border-radius: 16px;
      max-width: min(92vw, 620px);
      text-align: center;
      padding: 22px;
      box-shadow: 0 26px 70px rgba(0,0,0,0.55);
    }
    #center.hidden { display: none; }
    h1 { margin: 0 0 10px; font-size: clamp(24px, 3vw, 34px); }
    p { margin: 9px 0; }
    .accent { color: var(--accent); }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    button {
      margin-top: 9px;
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      color: #fff;
      cursor: pointer;
      background: linear-gradient(120deg, #2b7eff, #1ec8ff);
    }
    .barWrap {
      margin-top: 9px;
      height: 10px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255,255,255,0.12);
    }
    .bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #7fffd8, #57c8ff, #6d85ff);
      transition: width .2s ease;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud" id="stats">
    <div><strong>üï≥Ô∏è Tama√±o:</strong> <span id="sizeText">1.00</span></div>
    <div><strong>‚≠ê Puntaje:</strong> <span id="scoreText">0</span></div>
    <div><strong>üì¶ Comidos:</strong> <span id="eatenText">0</span></div>
    <div><strong>üèôÔ∏è Stage:</strong> <span id="stageText">1 / 3</span></div>
    <div class="barWrap"><div class="bar" id="progressBar"></div></div>
    <small id="progressText">Com√© objetos chicos para crecer.</small>
  </div>

  <div class="hud" id="objective">
    <div><strong class="accent">Objetivo</strong></div>
    <div id="goalText">Expandite para tragar edificios</div>
    <div id="comboText" class="ok">Combo x1.00</div>
  </div>

  <div class="hud" id="controls">
    <strong>Controles</strong><br>
    WASD / Flechas: mover libremente<br>
    Shift: acelerar<br>
    Espacio: dash corto<br>
    Click izquierdo: mover hacia el punto clickeado<br>
    Rueda mouse: zoom de c√°mara<br>
    R: reiniciar stage
  </div>

  <div id="center">
    <h1>Hole City 3D</h1>
    <p>Update total de jugabilidad: c√°mara a√©rea limpia + movimiento estable + absorci√≥n confiable.</p>
    <p class="accent">Todo objeto del escenario es comible de forma progresiva.</p>
    <button id="startBtn">Empezar</button>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const stageConfigs = [
      {
        name: '1 - Distrito Residencial',
        world: 92,
        targetScore: 1700,
        theme: { skyA: 0x35538a, skyB: 0x101935, ground: 0x313c4c },
        sets: [
          { kind: 'small', count: 90 },
          { kind: 'trees', count: 42 },
          { kind: 'house', count: 40 },
          { kind: 'block', count: 16 }
        ]
      },
      {
        name: '2 - Centro Comercial',
        world: 118,
        targetScore: 5200,
        theme: { skyA: 0x624d8f, skyB: 0x131832, ground: 0x3c3650 },
        sets: [
          { kind: 'small', count: 130 },
          { kind: 'trees', count: 60 },
          { kind: 'house', count: 70 },
          { kind: 'block', count: 48 },
          { kind: 'tower', count: 16 }
        ]
      },
      {
        name: '3 - Megaciudad',
        world: 142,
        targetScore: 13000,
        theme: { skyA: 0x7f445b, skyB: 0x101527, ground: 0x432d38 },
        sets: [
          { kind: 'small', count: 170 },
          { kind: 'trees', count: 80 },
          { kind: 'house', count: 85 },
          { kind: 'block', count: 75 },
          { kind: 'tower', count: 40 },
          { kind: 'mega', count: 12 }
        ]
      }
    ];

    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game'), antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x101935, 55, 260);

    const camera = new THREE.PerspectiveCamera(58, 1, 0.1, 900);
    const cameraLook = new THREE.Vector3();

    scene.add(new THREE.HemisphereLight(0xa8cbff, 0x243247, 0.55));
    const sun = new THREE.DirectionalLight(0xffefd0, 1.15);
    sun.position.set(90, 130, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    scene.add(sun);

    const mats = {
      asphalt: new THREE.MeshStandardMaterial({ color: 0x1f2531, roughness: 0.98 }),
      ground: new THREE.MeshStandardMaterial({ color: 0x313c4c, roughness: 1.0 }),
      post: new THREE.MeshStandardMaterial({ color: 0x9aa2b4, roughness: 0.8 }),
      car: new THREE.MeshStandardMaterial({ color: 0xea5b88, roughness: 0.48, metalness: 0.3 }),
      treeTop: new THREE.MeshStandardMaterial({ color: 0x45aa68, roughness: 0.9 }),
      treeTrunk: new THREE.MeshStandardMaterial({ color: 0x6d4d2e, roughness: 1.0 }),
      house: new THREE.MeshStandardMaterial({ color: 0xd8b488, roughness: 0.85 }),
      roof: new THREE.MeshStandardMaterial({ color: 0x86363a, roughness: 0.9 }),
      block: new THREE.MeshStandardMaterial({ color: 0x8ba4cd, roughness: 0.55, metalness: 0.3 }),
      tower: new THREE.MeshStandardMaterial({ color: 0x9ba4bc, roughness: 0.5, metalness: 0.36 }),
      mega: new THREE.MeshStandardMaterial({ color: 0xa49eb9, roughness: 0.46, metalness: 0.42 }),
      ring: new THREE.MeshStandardMaterial({ color: 0x11172e, emissive: 0x111e43, emissiveIntensity: 0.48, roughness: 0.55 }),
      core: new THREE.MeshBasicMaterial({ color: 0x000000 }),
      marker: new THREE.MeshBasicMaterial({ color: 0x53d1ff, transparent: true, opacity: 0.78 })
    };

    const state = {
      started: false,
      running: false,
      stage: 0,
      score: 0,
      eaten: 0,
      combo: 1,
      comboTimer: 0,
      size: 1,
      speedBoost: 1,
      sprint: 1,
      objects: [],
      keys: {},
      velocity: new THREE.Vector3(),
      worldSize: stageConfigs[0].world,
      clickTarget: null,
      camHeight: 36,
      camTiltOffset: 8,
      pointerNdc: new THREE.Vector2()
    };

    let ground, roads;
    const raycaster = new THREE.Raycaster();
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

    const hole = new THREE.Group();
    const ring = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.8, 0.32, 36, 1, true), mats.ring);
    ring.rotation.x = Math.PI / 2;
    ring.castShadow = true;
    ring.receiveShadow = true;
    const core = new THREE.Mesh(new THREE.CircleGeometry(0.96, 36), mats.core);
    core.rotation.x = -Math.PI / 2;
    core.position.y = -0.17;
    hole.add(ring, core);
    hole.position.set(0, 0.12, 0);
    scene.add(hole);

    const clickMarker = new THREE.Mesh(new THREE.RingGeometry(0.45, 0.66, 28), mats.marker);
    clickMarker.rotation.x = -Math.PI / 2;
    clickMarker.position.y = 0.03;
    clickMarker.visible = false;
    scene.add(clickMarker);

    const ui = {
      size: document.getElementById('sizeText'),
      score: document.getElementById('scoreText'),
      eaten: document.getElementById('eatenText'),
      stage: document.getElementById('stageText'),
      progress: document.getElementById('progressBar'),
      progressText: document.getElementById('progressText'),
      goal: document.getElementById('goalText'),
      combo: document.getElementById('comboText'),
      center: document.getElementById('center'),
      startBtn: document.getElementById('startBtn')
    };

    function seeded(seed) {
      return () => {
        seed = (seed * 1664525 + 1013904223) >>> 0;
        return seed / 4294967296;
      };
    }

    function setTheme(cfg) {
      document.body.style.background = `radial-gradient(circle at 20% 12%, #${cfg.theme.skyA.toString(16).padStart(6, '0')}, #${cfg.theme.skyB.toString(16).padStart(6, '0')} 58%, #05070f 100%)`;
      scene.fog.color.setHex(cfg.theme.skyB);
    }

    function clearWorld() {
      state.objects.forEach(o => scene.remove(o.mesh));
      state.objects = [];
      if (ground) scene.remove(ground);
      if (roads) scene.remove(roads);
    }

    function addObject(mesh, consumeRadius, needSize, points) {
      scene.add(mesh);
      state.objects.push({ mesh, consumeRadius, needSize, points, eaten: false, wobble: Math.random() * Math.PI * 2 });
    }

    function randPos(rng, span) {
      return (rng() - 0.5) * span;
    }

    function spawnStage(index) {
      const cfg = stageConfigs[index];
      state.worldSize = cfg.world;
      clearWorld();
      setTheme(cfg);

      ground = new THREE.Mesh(new THREE.PlaneGeometry(cfg.world, cfg.world), mats.ground.clone());
      ground.material.color.setHex(cfg.theme.ground);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      roads = new THREE.Group();
      scene.add(roads);
      for (let x = -cfg.world / 2; x <= cfg.world / 2; x += 14) {
        const road = new THREE.Mesh(new THREE.BoxGeometry(2.9, 0.05, cfg.world), mats.asphalt);
        road.position.set(x, 0.028, 0);
        road.receiveShadow = true;
        roads.add(road);
      }
      for (let z = -cfg.world / 2; z <= cfg.world / 2; z += 14) {
        const road = new THREE.Mesh(new THREE.BoxGeometry(cfg.world, 0.05, 2.9), mats.asphalt);
        road.position.set(0, 0.028, z);
        road.receiveShadow = true;
        roads.add(road);
      }

      const rng = seeded((index + 7) * 73421);

      const makeTree = () => {
        const g = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.22, 1.5, 9), mats.treeTrunk);
        trunk.position.y = 0.75;
        const top = new THREE.Mesh(new THREE.SphereGeometry(0.85 + rng() * 0.35, 11, 9), mats.treeTop);
        top.position.y = 1.75;
        g.add(trunk, top);
        return { mesh: g, consumeRadius: 0.82, needSize: 0.86, points: 25, y: 0 };
      };

      const makeHouse = () => {
        const g = new THREE.Group();
        const w = 2.7 + rng() * 1.8;
        const d = 2.7 + rng() * 1.8;
        const h = 1.8 + rng() * 1.1;
        const base = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mats.house.clone());
        base.material.color.offsetHSL((rng() - 0.5) * 0.08, 0, (rng() - 0.5) * 0.1);
        base.position.y = h / 2;
        const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w, d) * 0.7, 1.0, 4), mats.roof.clone());
        roof.position.y = h + 0.5;
        roof.rotation.y = Math.PI / 4;
        g.add(base, roof);
        return { mesh: g, consumeRadius: Math.max(w, d) * 0.48, needSize: Math.max(w, d) * 0.52, points: 68 + Math.round(h * 12), y: 0 };
      };

      const makeBlock = () => {
        const w = 3 + rng() * 1.5;
        const d = 3 + rng() * 1.5;
        const h = 4 + rng() * 6;
        const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mats.block.clone());
        m.position.y = h / 2;
        m.material.color.offsetHSL((rng() - 0.5) * 0.04, 0, (rng() - 0.5) * 0.08);
        return { mesh: m, consumeRadius: Math.max(w, d) * 0.56, needSize: Math.max(w, d) * 0.64, points: 160 + Math.round(h * 24), y: h / 2 };
      };

      const makeTower = () => {
        const w = 4.8 + rng() * 2.3;
        const d = 4.8 + rng() * 2.3;
        const h = 12 + rng() * 16;
        const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mats.tower.clone());
        m.position.y = h / 2;
        return { mesh: m, consumeRadius: Math.max(w, d) * 0.58, needSize: Math.max(w, d) * 0.7, points: 540 + Math.round(h * 34), y: h / 2 };
      };

      const makeMega = () => {
        const g = new THREE.Group();
        const bW = 7 + rng() * 3;
        const bD = 7 + rng() * 3;
        const bH = 10 + rng() * 7;
        const tW = bW * (0.58 + rng() * 0.14);
        const tD = bD * (0.58 + rng() * 0.14);
        const tH = 16 + rng() * 14;
        const b = new THREE.Mesh(new THREE.BoxGeometry(bW, bH, bD), mats.mega.clone());
        const t = new THREE.Mesh(new THREE.BoxGeometry(tW, tH, tD), mats.mega.clone());
        b.position.y = bH / 2;
        t.position.y = bH + tH / 2;
        g.add(b, t);
        return { mesh: g, consumeRadius: Math.max(bW, bD) * 0.7, needSize: Math.max(bW, bD) * 0.86, points: 1400 + Math.round(tH * 50), y: 0 };
      };

      for (const set of cfg.sets) {
        for (let i = 0; i < set.count; i++) {
          const x = randPos(rng, cfg.world * 0.9);
          const z = randPos(rng, cfg.world * 0.9);
          let data;

          if (set.kind === 'small') {
            if (rng() > 0.4) {
              const car = new THREE.Mesh(new THREE.BoxGeometry(1.16, 0.7, 2.1), mats.car.clone());
              car.material.color.offsetHSL((rng() - 0.5) * 0.2, 0, (rng() - 0.5) * 0.12);
              car.position.y = 0.45;
              data = { mesh: car, consumeRadius: 0.78, needSize: 0.72, points: 16, y: 0.45 };
            } else {
              const post = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.16, 2.2, 10), mats.post);
              post.position.y = 1.1;
              data = { mesh: post, consumeRadius: 0.42, needSize: 0.52, points: 10, y: 1.1 };
            }
          }
          if (set.kind === 'trees') data = makeTree();
          if (set.kind === 'house') data = makeHouse();
          if (set.kind === 'block') data = makeBlock();
          if (set.kind === 'tower') data = makeTower();
          if (set.kind === 'mega') data = makeMega();

          data.mesh.position.x = x;
          data.mesh.position.z = z;
          data.mesh.rotation.y = rng() * Math.PI * 2;
          data.mesh.castShadow = true;
          data.mesh.receiveShadow = true;
          addObject(data.mesh, data.consumeRadius, data.needSize, data.points);
        }
      }
    }

    function setPlayState(index, fullReset = true) {
      state.stage = index;
      if (fullReset) {
        state.score = 0;
        state.eaten = 0;
        state.size = 1;
        hole.scale.setScalar(1);
      }
      state.combo = 1;
      state.comboTimer = 0;
      state.sprint = 1;
      state.velocity.set(0, 0, 0);
      state.clickTarget = null;
      clickMarker.visible = false;
      hole.position.set(0, 0.12, 0);
      state.camHeight = 36 + state.size * 1.2;
      state.camTiltOffset = 8 + state.size * 0.35;
      spawnStage(index);
      ui.center.classList.add('hidden');
      state.running = true;
      state.started = true;
      updateUI();
    }

    function stageFinished() {
      if (state.stage < stageConfigs.length - 1) {
        const next = state.stage + 1;
        state.running = false;
        ui.center.innerHTML = `
          <h1>‚úÖ Stage completado</h1>
          <p>Pas√°s a <strong>${stageConfigs[next].name}</strong>.</p>
          <p class="accent">Ahora hay m√°s densidad y estructuras m√°s pesadas.</p>
          <button id="nextBtn">Continuar</button>
        `;
        ui.center.classList.remove('hidden');
        ui.center.querySelector('#nextBtn').onclick = () => setPlayState(next, false);
      } else {
        state.running = false;
        ui.center.innerHTML = `
          <h1>üèÜ Ciudad absorbida</h1>
          <p>Terminaste todos los stages.</p>
          <p>Puntaje: <strong>${Math.round(state.score).toLocaleString('es-AR')}</strong></p>
          <button id="restartBtn">Volver a jugar</button>
        `;
        ui.center.classList.remove('hidden');
        ui.center.querySelector('#restartBtn').onclick = () => setPlayState(0, true);
      }
    }

    function consume(obj) {
      obj.eaten = true;
      state.eaten += 1;
      state.comboTimer = 2.5;
      state.combo = Math.min(6, state.combo + 0.07);
      state.score += obj.points * state.combo;
      state.size += Math.max(0.015, obj.consumeRadius * 0.0088);
      hole.scale.setScalar(state.size);
      state.camHeight = THREE.MathUtils.clamp(34 + state.size * 1.45, 28, 68);
      state.camTiltOffset = THREE.MathUtils.clamp(8 + state.size * 0.5, 5, 24);
    }

    function updateUI() {
      const cfg = stageConfigs[state.stage];
      ui.size.textContent = state.size.toFixed(2);
      ui.score.textContent = Math.round(state.score).toLocaleString('es-AR');
      ui.eaten.textContent = String(state.eaten);
      ui.stage.textContent = `${state.stage + 1} / ${stageConfigs.length}`;

      const p = Math.min(1, state.score / cfg.targetScore);
      ui.progress.style.width = `${(p * 100).toFixed(1)}%`;
      ui.progressText.textContent = p < 1
        ? `Progreso: ${(p * 100).toFixed(1)}% ¬∑ objetivo ${cfg.targetScore.toLocaleString('es-AR')}`
        : 'Objetivo alcanzado: avanz√° de stage';

      const left = state.objects.filter(o => !o.eaten).length;
      ui.goal.textContent = `Comibles restantes: ${left}`;
      ui.combo.textContent = `Combo x${state.combo.toFixed(2)}`;
      ui.combo.className = state.combo > 2.3 ? 'warn' : 'ok';
    }

    function screenToWorld(clientX, clientY) {
      state.pointerNdc.x = (clientX / window.innerWidth) * 2 - 1;
      state.pointerNdc.y = -(clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(state.pointerNdc, camera);
      const hit = new THREE.Vector3();
      return raycaster.ray.intersectPlane(groundPlane, hit) ? hit : null;
    }

    function step(dt) {
      if (!state.running) return;
      const cfg = stageConfigs[state.stage];

      const input = new THREE.Vector3();
      if (state.keys['KeyW'] || state.keys['ArrowUp']) input.z -= 1;
      if (state.keys['KeyS'] || state.keys['ArrowDown']) input.z += 1;
      if (state.keys['KeyA'] || state.keys['ArrowLeft']) input.x -= 1;
      if (state.keys['KeyD'] || state.keys['ArrowRight']) input.x += 1;

      if (state.clickTarget) {
        const dx = state.clickTarget.x - hole.position.x;
        const dz = state.clickTarget.z - hole.position.z;
        const d = Math.hypot(dx, dz);
        if (d > 0.85) {
          input.x += dx / d;
          input.z += dz / d;
          clickMarker.position.set(state.clickTarget.x, 0.03, state.clickTarget.z);
          clickMarker.visible = true;
          clickMarker.rotation.z += dt * 2;
        } else {
          state.clickTarget = null;
          clickMarker.visible = false;
        }
      }

      if (input.lengthSq() > 0) input.normalize();

      let accel = 35 + state.size * 6;
      let maxSpeed = 9.5 + state.size * 2.2;
      if ((state.keys['ShiftLeft'] || state.keys['ShiftRight']) && state.sprint > 0.02) {
        maxSpeed *= 1.45;
        accel *= 1.25;
        state.sprint = Math.max(0, state.sprint - dt * 0.34);
      } else {
        state.sprint = Math.min(1, state.sprint + dt * 0.2);
      }
      if (state.keys['Space'] && state.sprint > 0.14) {
        state.sprint = Math.max(0, state.sprint - dt * 0.4);
        state.speedBoost = 1.45;
      }
      state.speedBoost = THREE.MathUtils.lerp(state.speedBoost, 1, dt * 3.6);
      maxSpeed *= state.speedBoost;

      const targetVel = input.multiplyScalar(maxSpeed);
      state.velocity.x = THREE.MathUtils.lerp(state.velocity.x, targetVel.x, dt * Math.min(1, accel * 0.06));
      state.velocity.z = THREE.MathUtils.lerp(state.velocity.z, targetVel.z, dt * Math.min(1, accel * 0.06));

      if (input.lengthSq() < 1e-4) {
        state.velocity.x *= Math.max(0, 1 - dt * 7.8);
        state.velocity.z *= Math.max(0, 1 - dt * 7.8);
      }

      hole.position.x += state.velocity.x * dt;
      hole.position.z += state.velocity.z * dt;

      const limit = cfg.world / 2 - 1.3;
      hole.position.x = THREE.MathUtils.clamp(hole.position.x, -limit, limit);
      hole.position.z = THREE.MathUtils.clamp(hole.position.z, -limit, limit);

      for (const obj of state.objects) {
        if (obj.eaten) {
          obj.mesh.scale.multiplyScalar(Math.max(0.01, 1 - dt * 8));
          obj.mesh.position.y -= dt * 3.2;
          if (obj.mesh.position.y < -8) scene.remove(obj.mesh);
          continue;
        }

        obj.wobble += dt;
        obj.mesh.position.y += Math.sin(obj.wobble * 2.5) * dt * 0.018;

        const dx = obj.mesh.position.x - hole.position.x;
        const dz = obj.mesh.position.z - hole.position.z;
        const d = Math.hypot(dx, dz);

        const pullRange = state.size * 3.2;
        if (d < pullRange) {
          const can = state.size >= obj.needSize;
          const force = (1 - d / pullRange) * dt * (can ? (2.2 + state.size * 0.35) : 0.45);
          obj.mesh.position.x -= dx * force;
          obj.mesh.position.z -= dz * force;
          obj.mesh.rotation.y += dt * 3.5;
        }

        if (d < state.size * 1.08 && state.size >= obj.needSize) {
          consume(obj);
        }
      }

      state.comboTimer -= dt;
      if (state.comboTimer <= 0) state.combo = Math.max(1, state.combo - dt * 0.9);

      if (state.score >= cfg.targetScore || state.objects.every(o => o.eaten)) {
        stageFinished();
      }

      const camTarget = new THREE.Vector3(hole.position.x, state.camHeight, hole.position.z + state.camTiltOffset);
      camera.position.lerp(camTarget, dt * 5.5);
      cameraLook.set(hole.position.x, 0, hole.position.z);
      camera.lookAt(cameraLook);

      updateUI();
    }

    function resize() {
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('keydown', (e) => {
      state.keys[e.code] = true;
      if (e.code === 'KeyR' && state.started) setPlayState(state.stage, false);
    });
    window.addEventListener('keyup', (e) => state.keys[e.code] = false);

    window.addEventListener('pointerdown', (e) => {
      const p = screenToWorld(e.clientX, e.clientY);
      if (p) {
        state.clickTarget = p.clone();
        clickMarker.position.set(p.x, 0.03, p.z);
        clickMarker.visible = true;
      }
    });

    window.addEventListener('wheel', (e) => {
      state.camHeight = THREE.MathUtils.clamp(state.camHeight + e.deltaY * 0.02, 24, 76);
      state.camTiltOffset = THREE.MathUtils.clamp(state.camTiltOffset + e.deltaY * 0.006, 4, 30);
    }, { passive: true });

    ui.startBtn.onclick = () => setPlayState(0, true);

    spawnStage(0);
    updateUI();

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      step(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    loop(performance.now());
  </script>
</body>
</html>
