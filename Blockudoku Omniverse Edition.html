<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Blockudoku Omniverse Edition</title>
  <style>
    :root {
      --bg: #020617;
      --card: #0f172a;
      --ink: #e2e8f0;
      --primary: #22d3ee;
      --secondary: #a78bfa;
      --accent: #f43f5e;
      --line: #1f2937;
      --sudoku: #3b82f6;
      --hint: #f59e0b;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Segoe UI', Inter, Roboto, sans-serif;
      background: radial-gradient(circle at 20% -10%, #0b2440 0%, var(--bg) 50%);
      color: var(--ink);
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: none;
      user-select: none;
      overflow: hidden;
    }

    .header {
      width: min(98vw, 520px);
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      align-items: stretch;
    }

    .score-display {
      background: linear-gradient(145deg, rgba(17, 24, 39, 0.9), rgba(2, 6, 23, 0.95));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 9px 12px;
      text-align: center;
      box-shadow: 0 0 18px rgba(34, 211, 238, 0.1);
    }

    .val { display: block; font-size: 24px; font-weight: 900; color: var(--primary); }
    .lbl { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.75; }

    .toolbar {
      width: min(98vw, 520px);
      margin: 8px 0 10px;
      display: flex;
      justify-content: flex-end;
    }

    .btn {
      border: 1px solid #334155;
      color: white;
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border-radius: 999px;
      padding: 8px 14px;
      font-weight: 700;
      cursor: pointer;
    }

    .btn:hover { border-color: var(--primary); }

    #board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      background: var(--line);
      padding: 4px;
      border-radius: 10px;
      border: 2px solid #334155;
      position: relative;
    }

    .cell {
      width: 40px;
      height: 40px;
      background: #020617;
      border-radius: 4px;
      transition: transform .12s ease, background-color .18s ease, box-shadow .18s ease;
    }

    .cell[data-col="2"], .cell[data-col="5"] { border-right: 3px solid var(--sudoku); }
    .cell[data-row="2"], .cell[data-row="5"] { border-bottom: 3px solid var(--sudoku); }

    .cell.filled {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      box-shadow: inset 0 0 10px rgba(255,255,255,0.35);
    }
    .cell.ghost { background: rgba(34, 211, 238, 0.22); }
    .cell.hint { background: rgba(245, 158, 11, 0.32); box-shadow: 0 0 12px rgba(245, 158, 11, 0.42); }

    .tray {
      margin-top: 16px;
      width: min(98vw, 520px);
      display: flex;
      justify-content: center;
      gap: 10px;
      align-items: center;
      min-height: 125px;
    }

    .slot {
      width: 120px;
      height: 120px;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color .15s ease, transform .15s ease;
    }

    .mini-grid { display: grid; gap: 2px; }
    .mini-block {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: var(--primary);
      border: 1px solid rgba(255,255,255,0.18);
    }

    .floating-piece {
      position: fixed;
      pointer-events: none;
      display: grid;
      z-index: 9999;
      gap: 2px;
      filter: drop-shadow(0 0 18px rgba(34, 211, 238, 0.9));
    }

    .p-block {
      width: 40px;
      height: 40px;
      border-radius: 5px;
      background: linear-gradient(135deg, #67e8f9, #a78bfa);
      border: 1px solid rgba(255,255,255,0.25);
    }

    #game-over {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.84);
      z-index: 10000;
    }

    .shake { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97); }
    @keyframes shake { 20%,80% {transform:translateX(2px);} 30%,50%,70%{transform:translateX(-3px);} }
  </style>
</head>
<body>
  <div class="header">
    <div class="score-display"><span class="lbl">RÃ©cord</span><span class="val" id="high-score">0</span></div>
    <div class="score-display"><span class="lbl">Puntos</span><span class="val" id="score">0</span></div>
    <div class="score-display"><span class="lbl">Espacios</span><span class="val" id="free-cells">81</span></div>
  </div>

  <div class="toolbar">
    <button class="btn" id="hint-btn">Sugerir jugada</button>
  </div>

  <div id="board"></div>

  <div class="tray">
    <div class="slot" id="slot-0"></div>
    <div class="slot" id="slot-1"></div>
    <div class="slot" id="slot-2"></div>
  </div>

  <div id="game-over">
    <h1 style="font-size:48px;color:var(--accent);margin:0;">GAME OVER</h1>
    <p id="final-score"></p>
    <button class="btn" onclick="location.reload()">Reintentar</button>
  </div>

  <script>
    const SHAPES = {
      dot:[[0,0]], h2:[[0,0],[0,1]], v2:[[0,0],[1,0]], h3:[[0,0],[0,1],[0,2]], v3:[[0,0],[1,0],[2,0]],
      h4:[[0,0],[0,1],[0,2],[0,3]], v4:[[0,0],[1,0],[2,0],[3,0]], h5:[[0,0],[0,1],[0,2],[0,3],[0,4]], v5:[[0,0],[1,0],[2,0],[3,0],[4,0]],
      sq2:[[0,0],[0,1],[1,0],[1,1]], sq3:[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
      t_up:[[0,1],[1,0],[1,1],[1,2]], t_down:[[0,0],[0,1],[0,2],[1,1]], t_left:[[0,1],[1,0],[1,1],[2,1]], t_right:[[0,0],[1,0],[1,1],[2,0]],
      l1:[[0,0],[1,0],[2,0],[2,1]], l2:[[0,1],[1,1],[2,1],[2,0]], l3:[[0,0],[0,1],[1,0],[2,0]], l4:[[0,0],[0,1],[1,1],[2,1]],
      s1:[[0,1],[0,2],[1,0],[1,1]], z1:[[0,0],[0,1],[1,1],[1,2]],
      plus:[[0,1],[1,0],[1,1],[1,2],[2,1]], u_shape:[[0,0],[0,2],[1,0],[1,1],[1,2]],
      c_shape:[[0,0],[0,1],[1,0],[2,0],[2,1]], w_shape:[[0,0],[1,0],[1,1],[2,1],[2,2]],
      stairs:[[0,0],[1,0],[1,1],[2,1],[2,2]], big_l:[[0,0],[1,0],[2,0],[3,0],[3,1]],
      hook:[[0,0],[0,1],[1,0],[2,0],[3,0]], long_z:[[0,0],[0,1],[1,1],[2,1],[2,2]],
      corner3:[[0,0],[1,0],[1,1]], zig3:[[0,0],[0,1],[1,1]], tri_line:[[0,0],[1,0],[1,1]],
      frame:[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]], ring4:[[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]],
      snake6:[[0,0],[0,1],[1,1],[1,2],[2,2],[2,3]], bridge6:[[0,0],[1,0],[1,1],[1,2],[2,2],[3,2]]
    };

    const CATEGORIES = {
      RESCUE: ['dot','h2','v2','h3','v3','corner3','zig3','tri_line','sq2'],
      NORMAL: ['h4','v4','t_up','t_down','t_left','t_right','l1','l2','l3','l4','s1','z1','u_shape','plus'],
      HARD: ['h5','v5','sq3','c_shape','stairs','big_l','hook','long_z','w_shape','frame','ring4','snake6','bridge6']
    };

    const board = Array.from({length:9},()=>Array(9).fill(0));
    let score = 0;
    let highScore = Number(localStorage.getItem('blockudoku_high') || 0);
    let pieces = [null, null, null];
    let dragging = null;
    let dragEl = null;
    let assistCooldown = 0;
    let hintPulse = null;

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high-score');
    const freeEl = document.getElementById('free-cells');
    highEl.textContent = highScore;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSfx(freq, type='sine', dur=0.13, vol=0.08) {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
    }

    function initBoard() {
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          boardEl.appendChild(cell);
        }
      }
    }

    function getFreeCells() { return board.flat().filter(v => v===0).length; }

    function randomFrom(list) { return list[Math.floor(Math.random()*list.length)]; }

    function allPlacements(shape) {
      const result = [];
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (canPlace(shape, r, c)) result.push({r,c});
      return result;
    }

    function canPlace(shape, r, c) {
      return shape.every(([dr,dc]) => {
        const nr = r+dr, nc = c+dc;
        return nr>=0 && nr<9 && nc>=0 && nc<9 && board[nr][nc]===0;
      });
    }

    function collectClears(simBoard) {
      const map = new Map();
      const push = (r,c)=>map.set(`${r},${c}`,{r,c});
      for (let i=0;i<9;i++) {
        if (simBoard[i].every(v=>v===1)) for (let c=0;c<9;c++) push(i,c);
        const col = Array.from({length:9},(_,r)=>simBoard[r][i]);
        if (col.every(v=>v===1)) for (let r=0;r<9;r++) push(r,i);
      }
      for (let sr=0;sr<9;sr+=3) for (let sc=0;sc<9;sc+=3) {
        const sec = [];
        for (let r=sr;r<sr+3;r++) for (let c=sc;c<sc+3;c++) sec.push({r,c});
        if (sec.every(p=>simBoard[p.r][p.c]===1)) sec.forEach(p=>push(p.r,p.c));
      }
      return [...map.values()];
    }

    function evaluatePlacement(shape, r, c) {
      const sim = board.map(row=>[...row]);
      shape.forEach(([dr,dc]) => sim[r+dr][c+dc] = 1);
      const clears = collectClears(sim);
      const touchedRows = new Set(shape.map(([dr])=>r+dr)).size;
      const touchedCols = new Set(shape.map(([,dc])=>c+dc)).size;
      return clears.length * 4 + shape.length * 2 + touchedRows + touchedCols;
    }

    function pickSpawnShape(slotIndex) {
      const free = getFreeCells();
      const dense = 81 - free;
      let pool = dense > 52 ? CATEGORIES.RESCUE : dense > 35 ? [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL] : [...CATEGORIES.NORMAL, ...CATEGORIES.HARD];
      const noMovesNow = pieces.filter(Boolean).every(shape => allPlacements(shape).length === 0);
      const shouldInjectRescue = assistCooldown <= 0 && (
        (noMovesNow && Math.random() < 0.65) ||
        (free <= 12 && Math.random() < 0.45) ||
        (free <= 18 && Math.random() < 0.28)
      );

      if (shouldInjectRescue) {
        const fittingRescue = CATEGORIES.RESCUE.filter(name => allPlacements(SHAPES[name]).length > 0);
        if (fittingRescue.length) {
          assistCooldown = 3;
          return SHAPES[randomFrom(fittingRescue)];
        }
      }

      for (let tries=0; tries<14; tries++) {
        const candidate = SHAPES[randomFrom(pool)];
        if (free > 20 || allPlacements(candidate).length > 0) return candidate;
      }

      const guaranteed = [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL]
        .map(name => SHAPES[name])
        .find(shape => allPlacements(shape).length > 0);
      return guaranteed || SHAPES.dot;
    }

    function spawnPieces() {
      for (let i=0;i<3;i++) {
        if (pieces[i]) continue;
        pieces[i] = pickSpawnShape(i);
      }
      assistCooldown = Math.max(assistCooldown - 1, 0);
      renderTray();
    }

    function renderTray() {
      for (let i=0;i<3;i++) {
        const slot = document.getElementById(`slot-${i}`);
        slot.innerHTML = '';
        if (!pieces[i]) continue;
        const shape = pieces[i];
        const rMax = Math.max(...shape.map(p=>p[0])) + 1;
        const cMax = Math.max(...shape.map(p=>p[1])) + 1;
        const g = document.createElement('div');
        g.className = 'mini-grid';
        g.style.gridTemplateRows = `repeat(${rMax},16px)`;
        g.style.gridTemplateColumns = `repeat(${cMax},16px)`;
        for (const [r,c] of shape) {
          const b = document.createElement('div');
          b.className = 'mini-block';
          b.style.gridRow = r+1;
          b.style.gridColumn = c+1;
          g.appendChild(b);
        }
        slot.appendChild(g);
        slot.onpointerdown = e => startDrag(e, i);
      }
    }

    function startDrag(e, idx) {
      if (!pieces[idx]) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      dragging = { idx, shape: pieces[idx] };
      dragEl = document.createElement('div');
      dragEl.className = 'floating-piece';
      const shape = dragging.shape;
      const rMax = Math.max(...shape.map(p=>p[0])) + 1;
      const cMax = Math.max(...shape.map(p=>p[1])) + 1;
      dragEl.style.gridTemplateRows = `repeat(${rMax},40px)`;
      dragEl.style.gridTemplateColumns = `repeat(${cMax},40px)`;

      shape.forEach(([r,c]) => {
        const b = document.createElement('div');
        b.className = 'p-block';
        b.style.gridRow = r+1; b.style.gridColumn = c+1;
        dragEl.appendChild(b);
      });
      document.body.appendChild(dragEl);
      document.getElementById(`slot-${idx}`).style.opacity = 0.35;
      updateDragPos(e);
      playSfx(430, 'triangle', 0.1);
    }

    function getCellAt(x,y) {
      const el = document.elementFromPoint(x,y);
      if (el?.classList.contains('cell')) return { r: Number(el.dataset.row), c: Number(el.dataset.col) };
      return null;
    }

    function clearHighlights() {
      document.querySelectorAll('.cell.ghost,.cell.hint').forEach(c => c.classList.remove('ghost','hint'));
    }

    function updateDragPos(e) {
      if (!dragEl || !dragging) return;
      const x = e.clientX;
      const y = e.clientY - 110;
      dragEl.style.left = `${x - 20}px`;
      dragEl.style.top = `${y - 20}px`;
      clearHighlights();
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        dragging.shape.forEach(([dr,dc]) => {
          const c = document.querySelector(`.cell[data-row="${target.r+dr}"][data-col="${target.c+dc}"]`);
          c?.classList.add('ghost');
        });
      }
    }

    function checkAnyMovePossible() {
      return pieces.some(shape => !shape || allPlacements(shape).length > 0);
    }

    function clearAndScore() {
      const clearList = collectClears(board);
      if (!clearList.length) return 0;
      clearList.forEach(({r,c}) => board[r][c] = 0);
      score += clearList.length * 15;
      boardEl.classList.add('shake');
      setTimeout(()=>boardEl.classList.remove('shake'), 300);
      playSfx(940, 'square', 0.14); playSfx(1180, 'sine', 0.16);
      return clearList.length;
    }

    function placePiece(shape, r, c, idx) {
      shape.forEach(([dr,dc]) => board[r+dr][c+dc] = 1);
      score += shape.length * 10;
      clearAndScore();
      pieces[idx] = null;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('blockudoku_high', highScore);
      }
      if (pieces.every(p => !p)) spawnPieces();
      else renderTray();
      updateBoardUI();
      if (!checkAnyMovePossible()) showGameOver();
      playSfx(620 + (score % 180), 'sine', 0.1);
    }

    function bestMoveSuggestion() {
      let best = null;
      for (let i=0;i<3;i++) {
        const shape = pieces[i];
        if (!shape) continue;
        for (const pos of allPlacements(shape)) {
          const value = evaluatePlacement(shape, pos.r, pos.c);
          if (!best || value > best.value) best = { idx:i, shape, ...pos, value };
        }
      }
      return best;
    }

    function applyHint() {
      const move = bestMoveSuggestion();
      clearHighlights();
      if (!move) return;
      move.shape.forEach(([dr,dc]) => {
        const cell = document.querySelector(`.cell[data-row="${move.r+dr}"][data-col="${move.c+dc}"]`);
        cell?.classList.add('hint');
      });
      if (hintPulse) clearTimeout(hintPulse);
      hintPulse = setTimeout(clearHighlights, 1700);
    }

    function updateBoardUI() {
      document.querySelectorAll('.cell').forEach(cell => {
        const filled = board[cell.dataset.row][cell.dataset.col] === 1;
        cell.classList.toggle('filled', filled);
      });
      scoreEl.textContent = score;
      highEl.textContent = highScore;
      freeEl.textContent = getFreeCells();
    }

    function showGameOver() {
      document.getElementById('final-score').textContent = `Puntaje final: ${score}`;
      document.getElementById('game-over').style.display = 'flex';
    }

    window.onpointermove = updateDragPos;
    window.onpointerup = e => {
      if (!dragging) return;
      const x = e.clientX, y = e.clientY - 110;
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        placePiece(dragging.shape, target.r, target.c, dragging.idx);
      } else {
        document.getElementById(`slot-${dragging.idx}`).style.opacity = 1;
        playSfx(180, 'sawtooth', 0.1);
      }
      clearHighlights();
      dragEl?.remove();
      dragEl = null;
      dragging = null;
      renderTray();
    };

    document.getElementById('hint-btn').addEventListener('click', applyHint);

    initBoard();
    spawnPieces();
    updateBoardUI();
  </script>
</body>
</html>
