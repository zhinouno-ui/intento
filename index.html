<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Blockudoku Omniverse Edition</title>
  <style>
    :root {
      --bg: #020617;
      --card: #0f172a;
      --ink: #e2e8f0;
      --primary: #22d3ee;
      --secondary: #a78bfa;
      --accent: #f43f5e;
      --line: #1f2937;
      --sudoku: #3b82f6;
      --hint: #f59e0b;
      --ok: #34d399;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Segoe UI', Inter, Roboto, sans-serif;
      background: radial-gradient(circle at 20% -10%, #0b2440 0%, var(--bg) 50%);
      color: var(--ink);
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: none;
      user-select: none;
      overflow: hidden;
      padding-bottom: 10px;
    }

    .header,
    .telemetry {
      width: min(98vw, 560px);
      display: grid;
      gap: 10px;
      align-items: stretch;
    }

    .header {
      margin-top: 10px;
      grid-template-columns: repeat(3, 1fr);
    }

    .telemetry {
      margin-top: 8px;
      grid-template-columns: repeat(4, 1fr);
    }

    .score-display {
      background: linear-gradient(145deg, rgba(17, 24, 39, 0.92), rgba(2, 6, 23, 0.96));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 9px 12px;
      text-align: center;
      box-shadow: 0 0 18px rgba(34, 211, 238, 0.1);
    }

    .score-display.mini {
      padding: 7px 8px;
      border-radius: 12px;
    }

    .val { display: block; font-size: 24px; font-weight: 900; color: var(--primary); }
    .val.mini { font-size: 17px; }
    .lbl { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.75; }

    .status {
      width: min(98vw, 560px);
      margin: 8px 0 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }

    #hint-status {
      font-size: 13px;
      color: #cbd5e1;
      min-height: 1em;
      max-width: 300px;
    }

    .btn {
      border: 1px solid #334155;
      color: white;
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border-radius: 999px;
      padding: 8px 14px;
      font-weight: 700;
      cursor: pointer;
      font-size: 13px;
    }

    .btn:hover { border-color: var(--primary); }
    .btn.secondary { border-color: #475569; opacity: 0.92; }
    .btn.warn { border-color: #ef4444; }

    .progress-wrap {
      width: min(98vw, 560px);
      margin-top: -2px;
      margin-bottom: 8px;
    }

    .progress-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(71, 85, 105, 0.35);
      border: 1px solid rgba(100, 116, 139, 0.4);
      overflow: hidden;
    }

    #level-progress {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--ok), var(--primary));
      transition: width .2s ease;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      background: var(--line);
      padding: 4px;
      border-radius: 10px;
      border: 2px solid #334155;
      position: relative;
    }

    .cell {
      width: 40px;
      height: 40px;
      background: #020617;
      border-radius: 4px;
      transition: transform .12s ease, background-color .18s ease, box-shadow .18s ease;
    }

    .cell[data-col="2"], .cell[data-col="5"] { border-right: 3px solid var(--sudoku); }
    .cell[data-row="2"], .cell[data-row="5"] { border-bottom: 3px solid var(--sudoku); }

    .cell.filled {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      box-shadow: inset 0 0 10px rgba(255,255,255,0.35);
    }
    .cell.ghost { background: rgba(34, 211, 238, 0.22); }
    .cell.hint { background: rgba(245, 158, 11, 0.32); box-shadow: 0 0 12px rgba(245, 158, 11, 0.42); }
    .cell.hint-ok { background: rgba(52, 211, 153, 0.26); box-shadow: 0 0 14px rgba(52, 211, 153, 0.4); }

    .tray {
      margin-top: 16px;
      width: min(98vw, 560px);
      display: flex;
      justify-content: center;
      gap: 10px;
      align-items: center;
      min-height: 125px;
    }

    .slot {
      width: 120px;
      height: 120px;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color .15s ease, transform .15s ease;
    }

    .slot.assist { border-color: var(--ok); box-shadow: 0 0 18px rgba(52, 211, 153, 0.18); }

    .mini-grid { display: grid; gap: 2px; }
    .mini-block {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: var(--primary);
      border: 1px solid rgba(255,255,255,0.18);
    }

    .floating-piece {
      position: fixed;
      pointer-events: none;
      display: grid;
      z-index: 9999;
      gap: 2px;
      filter: drop-shadow(0 0 18px rgba(34, 211, 238, 0.9));
    }

    .p-block {
      width: 40px;
      height: 40px;
      border-radius: 5px;
      background: linear-gradient(135deg, #67e8f9, #a78bfa);
      border: 1px solid rgba(255,255,255,0.25);
    }

    .legend {
      margin-top: 9px;
      font-size: 11px;
      color: #94a3b8;
      opacity: 0.9;
    }

    #game-over {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(0, 0, 0, 0.84);
      z-index: 10000;
    }

    .game-over-card {
      width: min(92vw, 430px);
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: linear-gradient(160deg, rgba(15, 23, 42, 0.98), rgba(2, 6, 23, 0.98));
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.45);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      text-align: center;
    }

    .game-over-title {
      font-size: clamp(34px, 8vw, 48px);
      color: var(--accent);
      margin: 0;
      line-height: 1;
      letter-spacing: 1px;
    }

    .game-over-subtitle {
      margin: 0;
      color: #cbd5e1;
      font-size: 14px;
      opacity: 0.95;
    }

    .game-over-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }

    .game-stat {
      border-radius: 12px;
      border: 1px solid rgba(100, 116, 139, 0.45);
      background: rgba(15, 23, 42, 0.82);
      padding: 10px 8px;
    }

    .game-stat strong {
      display: block;
      color: var(--primary);
      font-size: 22px;
      line-height: 1.1;
    }

    .game-stat span {
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.76;
    }

    .game-over-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .shake { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97); }
    @keyframes shake { 20%,80% {transform:translateX(2px);} 30%,50%,70%{transform:translateX(-3px);} }

    @media (max-width: 600px) {
      .header, .telemetry, .status, .tray, .progress-wrap { width: min(98vw, 520px); }
      .status { flex-direction: column; align-items: stretch; }
      .actions { justify-content: flex-start; }
      #hint-status { max-width: unset; }
      .telemetry { grid-template-columns: repeat(2, 1fr); }
      body { overflow-y: auto; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="score-display"><span class="lbl">Récord</span><span class="val" id="high-score">0</span></div>
    <div class="score-display"><span class="lbl">Puntos</span><span class="val" id="score">0</span></div>
    <div class="score-display"><span class="lbl">Espacios</span><span class="val" id="free-cells">81</span></div>
  </div>

  <div class="telemetry">
    <div class="score-display mini"><span class="lbl">Nivel</span><span class="val mini" id="level">1</span></div>
    <div class="score-display mini"><span class="lbl">Combo</span><span class="val mini" id="combo">x0</span></div>
    <div class="score-display mini"><span class="lbl">Movimientos</span><span class="val mini" id="moves">0</span></div>
    <div class="score-display mini"><span class="lbl">IA Auto</span><span class="val mini" id="ai-state">ON</span></div>
  </div>

  <div class="status">
    <span id="hint-status">IA: analizando tablero…</span>
    <div class="actions">
      <button class="btn" id="hint-btn">Sugerir jugada</button>
      <button class="btn secondary" id="undo-btn">Deshacer</button>
      <button class="btn warn" id="reset-btn">Reiniciar</button>
    </div>
  </div>

  <div class="progress-wrap">
    <div class="progress-track"><div id="level-progress"></div></div>
  </div>

  <div id="board"></div>

  <div class="tray">
    <div class="slot" id="slot-0"></div>
    <div class="slot" id="slot-1"></div>
    <div class="slot" id="slot-2"></div>
  </div>

  <div class="legend">Atajos: <b>H</b> sugerencia · <b>U</b> deshacer · <b>R</b> reiniciar · <b>A</b> IA auto</div>

  <div id="game-over">
    <div class="game-over-card">
      <h1 class="game-over-title">GAME OVER</h1>
      <p class="game-over-subtitle" id="game-over-subtitle">Acá tenés el botón <b>Reintentar</b> para volver a jugar al instante.</p>
      <div class="game-over-stats">
        <div class="game-stat"><strong id="final-score">0</strong><span>Puntos</span></div>
        <div class="game-stat"><strong id="final-turns">0</strong><span>Turnos</span></div>
        <div class="game-stat"><strong id="final-clears">0</strong><span>Bloques limpiados</span></div>
      </div>
      <div class="game-over-actions">
        <button class="btn" id="retry-btn">Reintentar</button>
        <button class="btn secondary" id="close-over-btn">Cerrar</button>
      </div>
    </div>
  </div>

  <script>
    const SHAPES = {
      dot:[[0,0]], h2:[[0,0],[0,1]], v2:[[0,0],[1,0]], h3:[[0,0],[0,1],[0,2]], v3:[[0,0],[1,0],[2,0]],
      h4:[[0,0],[0,1],[0,2],[0,3]], v4:[[0,0],[1,0],[2,0],[3,0]], h5:[[0,0],[0,1],[0,2],[0,3],[0,4]], v5:[[0,0],[1,0],[2,0],[3,0],[4,0]],
      sq2:[[0,0],[0,1],[1,0],[1,1]], sq3:[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
      t_up:[[0,1],[1,0],[1,1],[1,2]], t_down:[[0,0],[0,1],[0,2],[1,1]], t_left:[[0,1],[1,0],[1,1],[2,1]], t_right:[[0,0],[1,0],[1,1],[2,0]],
      l1:[[0,0],[1,0],[2,0],[2,1]], l2:[[0,1],[1,1],[2,1],[2,0]], l3:[[0,0],[0,1],[1,0],[2,0]], l4:[[0,0],[0,1],[1,1],[2,1]],
      s1:[[0,1],[0,2],[1,0],[1,1]], z1:[[0,0],[0,1],[1,1],[1,2]],
      plus:[[0,1],[1,0],[1,1],[1,2],[2,1]], u_shape:[[0,0],[0,2],[1,0],[1,1],[1,2]],
      c_shape:[[0,0],[0,1],[1,0],[2,0],[2,1]], w_shape:[[0,0],[1,0],[1,1],[2,1],[2,2]],
      stairs:[[0,0],[1,0],[1,1],[2,1],[2,2]], big_l:[[0,0],[1,0],[2,0],[3,0],[3,1]],
      hook:[[0,0],[0,1],[1,0],[2,0],[3,0]], long_z:[[0,0],[0,1],[1,1],[2,1],[2,2]],
      corner3:[[0,0],[1,0],[1,1]], zig3:[[0,0],[0,1],[1,1]], tri_line:[[0,0],[1,0],[1,1]],
      frame:[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]], ring4:[[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]],
      snake6:[[0,0],[0,1],[1,1],[1,2],[2,2],[2,3]], bridge6:[[0,0],[1,0],[1,1],[1,2],[2,2],[3,2]]
    };

    const CATEGORIES = {
      RESCUE: ['dot','h2','v2','h3','v3','corner3','zig3','tri_line','sq2'],
      NORMAL: ['h4','v4','t_up','t_down','t_left','t_right','l1','l2','l3','l4','s1','z1','u_shape','plus'],
      HARD: ['h5','v5','sq3','c_shape','stairs','big_l','hook','long_z','w_shape','frame','ring4','snake6','bridge6']
    };

    const board = Array.from({length:9},()=>Array(9).fill(0));
    let score = 0;
    let level = 1;
    let moves = 0;
    let comboStreak = 0;
    let maxCombo = 0;
    let totalClears = 0;
    let highScore = Number(localStorage.getItem('blockudoku_high') || 0);
    let pieces = [null, null, null];
    let pieceMeta = [{assist:false},{assist:false},{assist:false}];
    let dragging = null;
    let dragEl = null;
    let turn = 0;
    let assistCooldown = 0;
    let hintPulse = null;
    let gameEnded = false;
    let aiAuto = true;
    let history = [];

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high-score');
    const freeEl = document.getElementById('free-cells');
    const levelEl = document.getElementById('level');
    const comboEl = document.getElementById('combo');
    const movesEl = document.getElementById('moves');
    const aiStateEl = document.getElementById('ai-state');
    const levelProgressEl = document.getElementById('level-progress');
    const hintStatusEl = document.getElementById('hint-status');
    const gameOverEl = document.getElementById('game-over');
    highEl.textContent = highScore;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSfx(freq, type='sine', dur=0.13, vol=0.08) {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
    }

    function initBoard() {
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          boardEl.appendChild(cell);
        }
      }
    }

    function getFreeCells(simBoard = board) { return simBoard.flat().filter(v => v===0).length; }
    function randomFrom(list) { return list[Math.floor(Math.random()*list.length)]; }
    function deepBoard(src) { return src.map(row => [...row]); }

    function allPlacements(shape, simBoard = board) {
      const result = [];
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (canPlace(shape, r, c, simBoard)) result.push({r,c});
      return result;
    }

    function canPlace(shape, r, c, simBoard = board) {
      return shape.every(([dr,dc]) => {
        const nr = r+dr, nc = c+dc;
        return nr>=0 && nr<9 && nc>=0 && nc<9 && simBoard[nr][nc]===0;
      });
    }

    function collectClears(simBoard) {
      const map = new Map();
      const push = (r,c)=>map.set(`${r},${c}`,{r,c});
      for (let i=0;i<9;i++) {
        if (simBoard[i].every(v=>v===1)) for (let c=0;c<9;c++) push(i,c);
        const col = Array.from({length:9},(_,r)=>simBoard[r][i]);
        if (col.every(v=>v===1)) for (let r=0;r<9;r++) push(r,i);
      }
      for (let sr=0;sr<9;sr+=3) for (let sc=0;sc<9;sc+=3) {
        const sec = [];
        for (let r=sr;r<sr+3;r++) for (let c=sc;c<sc+3;c++) sec.push({r,c});
        if (sec.every(p=>simBoard[p.r][p.c]===1)) sec.forEach(p=>push(p.r,p.c));
      }
      return [...map.values()];
    }

    function simulatePlacement(baseBoard, shape, r, c) {
      const sim = deepBoard(baseBoard);
      shape.forEach(([dr,dc]) => sim[r+dr][c+dc] = 1);
      const clears = collectClears(sim);
      clears.forEach(({r:rr, c:cc}) => sim[rr][cc] = 0);
      return { sim, clears: clears.length };
    }

    function boardMetrics(simBoard) {
      const free = getFreeCells(simBoard);
      const crowdedRows = simBoard.reduce((acc, row) => acc + (row.filter(v=>v===1).length >= 7 ? 1 : 0), 0);
      const crowdedCols = Array.from({length:9}, (_,c) => simBoard.map(r => r[c]).filter(v=>v===1).length)
        .reduce((acc, amount) => acc + (amount >= 7 ? 1 : 0), 0);
      const singleHoles = simBoard.flatMap((row, r) => row.map((v, c) => ({v,r,c})))
        .filter(p => p.v===0)
        .reduce((acc, p) => {
          const adj = [[1,0],[-1,0],[0,1],[0,-1]]
            .map(([dr,dc]) => [p.r+dr,p.c+dc])
            .filter(([rr,cc]) => rr>=0 && rr<9 && cc>=0 && cc<9)
            .filter(([rr,cc]) => simBoard[rr][cc]===0).length;
          return acc + (adj <= 1 ? 1 : 0);
        }, 0);
      return { free, pressure: crowdedRows + crowdedCols, singleHoles };
    }

    function evaluatePlacement(shape, r, c, idx) {
      const first = simulatePlacement(board, shape, r, c);
      const touchedRows = new Set(shape.map(([dr])=>r+dr)).size;
      const touchedCols = new Set(shape.map(([,dc])=>c+dc)).size;
      const firstMetrics = boardMetrics(first.sim);

      let followBest = -Infinity;
      let followMoves = 0;
      for (let j=0;j<3;j++) {
        if (j === idx || !pieces[j]) continue;
        for (const nextPos of allPlacements(pieces[j], first.sim)) {
          followMoves++;
          const second = simulatePlacement(first.sim, pieces[j], nextPos.r, nextPos.c);
          const secondMetrics = boardMetrics(second.sim);
          const secondScore = second.clears * 24 + secondMetrics.free * 0.32 - secondMetrics.pressure * 4.2 - secondMetrics.singleHoles * 1.5;
          if (secondScore > followBest) followBest = secondScore;
        }
      }
      if (!Number.isFinite(followBest)) followBest = -30;

      const rescueBonus = pieceMeta[idx]?.assist ? 9 : 0;
      return {
        value:
          shape.length * 8.4 +
          first.clears * 26 +
          touchedRows * 1.1 +
          touchedCols * 1.1 +
          firstMetrics.free * 0.34 -
          firstMetrics.pressure * 5.1 -
          firstMetrics.singleHoles * 2.1 +
          followMoves * 0.74 +
          followBest * 0.48 +
          rescueBonus,
        firstClears: first.clears,
        followMoves
      };
    }

    function pickSpawnShape() {
      const free = getFreeCells();
      const dense = 81 - free;
      const levelHardBias = Math.min(Math.floor(level / 2), 4);
      const normalPool = [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL];
      const hardPool = [...normalPool, ...CATEGORIES.HARD, ...CATEGORIES.HARD.slice(0, levelHardBias)];
      const pool = dense > 52 ? CATEGORIES.RESCUE : dense > 35 ? normalPool : hardPool;
      let assist = false;

      const noMovesNow = pieces.filter(Boolean).every(shape => allPlacements(shape).length === 0);
      const danger = free <= 18 || noMovesNow;

      if (danger && assistCooldown <= 0) {
        const fittingRescue = CATEGORIES.RESCUE.filter(name => allPlacements(SHAPES[name]).length > 0);
        if (fittingRescue.length) {
          assist = true;
          assistCooldown = 2;
          return { shape: SHAPES[randomFrom(fittingRescue)], assist };
        }
      }

      for (let tries=0; tries<16; tries++) {
        const candidate = SHAPES[randomFrom(pool)];
        if (free > 20 || allPlacements(candidate).length > 0) return { shape: candidate, assist };
      }

      const guaranteed = [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL]
        .map(name => SHAPES[name])
        .find(shape => allPlacements(shape).length > 0);
      return { shape: guaranteed || SHAPES.dot, assist: guaranteed ? true : assist };
    }

    function spawnPieces() {
      for (let i=0;i<3;i++) {
        if (pieces[i]) continue;
        const pick = pickSpawnShape();
        pieces[i] = pick.shape;
        pieceMeta[i] = { assist: pick.assist };
      }
      assistCooldown = Math.max(assistCooldown - 1, 0);
      renderTray();
      if (aiAuto) autoHint(true);
    }

    function renderTray() {
      for (let i=0;i<3;i++) {
        const slot = document.getElementById(`slot-${i}`);
        slot.classList.toggle('assist', !!pieceMeta[i]?.assist);
        slot.innerHTML = '';
        if (!pieces[i]) continue;
        const shape = pieces[i];
        const rMax = Math.max(...shape.map(p=>p[0])) + 1;
        const cMax = Math.max(...shape.map(p=>p[1])) + 1;
        const g = document.createElement('div');
        g.className = 'mini-grid';
        g.style.gridTemplateRows = `repeat(${rMax},16px)`;
        g.style.gridTemplateColumns = `repeat(${cMax},16px)`;
        for (const [r,c] of shape) {
          const b = document.createElement('div');
          b.className = 'mini-block';
          b.style.gridRow = r+1;
          b.style.gridColumn = c+1;
          if (pieceMeta[i]?.assist) b.style.background = 'var(--ok)';
          g.appendChild(b);
        }
        slot.appendChild(g);
        slot.onpointerdown = e => startDrag(e, i);
      }
    }

    function startDrag(e, idx) {
      if (!pieces[idx] || gameEnded) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      dragging = { idx, shape: pieces[idx] };
      dragEl = document.createElement('div');
      dragEl.className = 'floating-piece';
      const shape = dragging.shape;
      const rMax = Math.max(...shape.map(p=>p[0])) + 1;
      const cMax = Math.max(...shape.map(p=>p[1])) + 1;
      dragEl.style.gridTemplateRows = `repeat(${rMax},40px)`;
      dragEl.style.gridTemplateColumns = `repeat(${cMax},40px)`;

      shape.forEach(([r,c]) => {
        const b = document.createElement('div');
        b.className = 'p-block';
        b.style.gridRow = r+1;
        b.style.gridColumn = c+1;
        dragEl.appendChild(b);
      });
      document.body.appendChild(dragEl);
      document.getElementById(`slot-${idx}`).style.opacity = 0.35;
      updateDragPos(e);
      playSfx(430, 'triangle', 0.1);
    }

    function getCellAt(x,y) {
      const el = document.elementFromPoint(x,y);
      if (el?.classList.contains('cell')) return { r: Number(el.dataset.row), c: Number(el.dataset.col) };
      return null;
    }

    function clearHighlights() {
      document.querySelectorAll('.cell.ghost,.cell.hint,.cell.hint-ok').forEach(c => c.classList.remove('ghost','hint','hint-ok'));
    }

    function updateDragPos(e) {
      if (!dragEl || !dragging) return;
      const x = e.clientX;
      const y = e.clientY - 110;
      dragEl.style.left = `${x - 20}px`;
      dragEl.style.top = `${y - 20}px`;
      clearHighlights();
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        dragging.shape.forEach(([dr,dc]) => {
          const c = document.querySelector(`.cell[data-row="${target.r+dr}"][data-col="${target.c+dc}"]`);
          c?.classList.add('ghost');
        });
      }
    }

    function checkAnyMovePossible() {
      return pieces.some(shape => !shape || allPlacements(shape).length > 0);
    }

    function clearBoardCells() {
      const clearList = collectClears(board);
      clearList.forEach(({r,c}) => board[r][c] = 0);
      return clearList.length;
    }

    function saveHistory() {
      history.push({
        board: deepBoard(board),
        score,
        level,
        moves,
        comboStreak,
        maxCombo,
        totalClears,
        highScore,
        pieces: pieces.map(p => p ? p.map(([r,c]) => [r,c]) : null),
        pieceMeta: pieceMeta.map(m => ({...m})),
        turn,
        assistCooldown,
        gameEnded
      });
      if (history.length > 8) history.shift();
    }

    function undoMove() {
      if (!history.length || gameEnded) {
        hintStatusEl.textContent = gameEnded ? 'IA: no se puede deshacer con partida terminada.' : 'IA: no hay jugadas para deshacer.';
        return;
      }
      const prev = history.pop();
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) board[r][c] = prev.board[r][c];
      score = prev.score;
      level = prev.level;
      moves = prev.moves;
      comboStreak = prev.comboStreak;
      maxCombo = prev.maxCombo;
      totalClears = prev.totalClears;
      highScore = prev.highScore;
      pieces = prev.pieces;
      pieceMeta = prev.pieceMeta;
      turn = prev.turn;
      assistCooldown = prev.assistCooldown;
      gameEnded = prev.gameEnded;
      renderTray();
      updateBoardUI();
      hintStatusEl.textContent = 'IA: última jugada deshecha.';
      playSfx(260, 'triangle', 0.1);
    }

    function applyScoring(clearedCells, shapeSize) {
      let gain = shapeSize * 10;
      if (clearedCells > 0) {
        comboStreak++;
        maxCombo = Math.max(maxCombo, comboStreak);
        gain += Math.round(clearedCells * (12 + comboStreak * 3));
      } else {
        comboStreak = 0;
      }
      score += gain;
      level = 1 + Math.floor(score / 900);
      return gain;
    }

    function placePiece(shape, r, c, idx) {
      if (gameEnded) return;
      saveHistory();
      shape.forEach(([dr,dc]) => board[r+dr][c+dc] = 1);
      const clearedCells = clearBoardCells();
      const gain = applyScoring(clearedCells, shape.length);
      totalClears += clearedCells;
      pieces[idx] = null;
      pieceMeta[idx] = {assist:false};
      turn++;
      moves++;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('blockudoku_high', highScore);
      }

      if (clearedCells > 0) {
        boardEl.classList.add('shake');
        setTimeout(()=>boardEl.classList.remove('shake'), 300);
        playSfx(920 + comboStreak * 35, 'square', 0.12);
      }

      if (pieces.every(p => !p)) spawnPieces();
      else renderTray();

      updateBoardUI();
      if (aiAuto) autoHint(false);
      if (!checkAnyMovePossible()) showGameOver();
      playSfx(620 + (gain % 180), 'sine', 0.1);
    }

    function bestMoveSuggestion() {
      let best = null;
      for (let i=0;i<3;i++) {
        const shape = pieces[i];
        if (!shape) continue;
        for (const pos of allPlacements(shape)) {
          const prediction = evaluatePlacement(shape, pos.r, pos.c, i);
          if (!best || prediction.value > best.value) {
            best = { idx:i, shape, ...pos, ...prediction };
          }
        }
      }
      return best;
    }

    function applyHint(kind='hint') {
      const move = bestMoveSuggestion();
      clearHighlights();
      if (!move) {
        hintStatusEl.textContent = 'IA: no hay jugada posible con piezas actuales.';
        return;
      }
      move.shape.forEach(([dr,dc]) => {
        const cell = document.querySelector(`.cell[data-row="${move.r+dr}"][data-col="${move.c+dc}"]`);
        cell?.classList.add(kind === 'ok' ? 'hint-ok' : 'hint');
      });
      hintStatusEl.textContent = `IA: pieza ${move.idx + 1} en (${move.r + 1},${move.c + 1}) · clears:${move.firstClears} · futuro:${move.followMoves}`;
      if (hintPulse) clearTimeout(hintPulse);
      hintPulse = setTimeout(clearHighlights, 1700);
    }

    function autoHint(isSpawn) {
      const free = getFreeCells();
      const playableMoves = pieces.filter(Boolean).reduce((acc, shape) => acc + allPlacements(shape).length, 0);
      const shouldHelp = free <= 22 || playableMoves <= 7 || (isSpawn && free <= 28);
      hintStatusEl.textContent = shouldHelp
        ? 'IA: tablero crítico detectado, activando ayuda predictiva.'
        : `IA: estado estable · ${playableMoves} jugadas posibles.`;
      if (shouldHelp) applyHint('ok');
    }

    function updateBoardUI() {
      document.querySelectorAll('.cell').forEach(cell => {
        const filled = board[cell.dataset.row][cell.dataset.col] === 1;
        cell.classList.toggle('filled', filled);
      });
      scoreEl.textContent = score;
      highEl.textContent = highScore;
      freeEl.textContent = getFreeCells();
      levelEl.textContent = level;
      comboEl.textContent = `x${comboStreak}`;
      movesEl.textContent = moves;
      aiStateEl.textContent = aiAuto ? 'ON' : 'OFF';
      const progress = ((score % 900) / 900) * 100;
      levelProgressEl.style.width = `${Math.max(4, progress)}%`;
    }

    function showGameOver() {
      gameEnded = true;
      document.getElementById('final-score').textContent = score;
      document.getElementById('final-turns').textContent = turn;
      document.getElementById('final-clears').textContent = totalClears;
      const subtitle = score >= highScore
        ? `Nuevo récord desbloqueado con combo máximo x${maxCombo}.`
        : `Te faltaron ${highScore - score} puntos para el récord. Usa Reintentar para revancha.`;
      document.getElementById('game-over-subtitle').textContent = subtitle;
      gameOverEl.style.display = 'flex';
      clearHighlights();
      if (hintPulse) clearTimeout(hintPulse);
    }

    function resetGame() {
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) board[r][c] = 0;
      score = 0;
      level = 1;
      moves = 0;
      comboStreak = 0;
      maxCombo = 0;
      totalClears = 0;
      pieces = [null, null, null];
      pieceMeta = [{assist:false},{assist:false},{assist:false}];
      turn = 0;
      assistCooldown = 0;
      gameEnded = false;
      history = [];
      clearHighlights();
      gameOverEl.style.display = 'none';
      hintStatusEl.textContent = 'IA: nueva partida iniciada. Analizando tablero…';
      spawnPieces();
      updateBoardUI();
      playSfx(500, 'triangle', 0.08);
    }

    function toggleAiAuto() {
      aiAuto = !aiAuto;
      updateBoardUI();
      hintStatusEl.textContent = aiAuto ? 'IA Auto activada.' : 'IA Auto desactivada.';
    }

    window.onpointermove = updateDragPos;
    window.onpointerup = e => {
      if (gameEnded || !dragging) return;
      const x = e.clientX, y = e.clientY - 110;
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        placePiece(dragging.shape, target.r, target.c, dragging.idx);
      } else {
        document.getElementById(`slot-${dragging.idx}`).style.opacity = 1;
        playSfx(180, 'sawtooth', 0.1);
        if (aiAuto) autoHint(false);
      }
      clearHighlights();
      dragEl?.remove();
      dragEl = null;
      dragging = null;
      renderTray();
    };

    document.getElementById('hint-btn').addEventListener('click', () => applyHint('hint'));
    document.getElementById('undo-btn').addEventListener('click', undoMove);
    document.getElementById('reset-btn').addEventListener('click', resetGame);
    document.getElementById('retry-btn').addEventListener('click', resetGame);
    document.getElementById('close-over-btn').addEventListener('click', () => gameOverEl.style.display = 'none');

    window.addEventListener('keydown', (e) => {
      if (e.key === 'h' || e.key === 'H') applyHint('hint');
      if (e.key === 'u' || e.key === 'U') undoMove();
      if (e.key === 'r' || e.key === 'R') resetGame();
      if (e.key === 'a' || e.key === 'A') toggleAiAuto();
    });

    initBoard();
    spawnPieces();
    updateBoardUI();
  </script>
</body>
</html>
