<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Blockudoku Omniverse Edition</title>
  <style>
    :root {
      --bg: #020617;
      --card: #0f172a;
      --ink: #e2e8f0;
      --primary: #22d3ee;
      --secondary: #a78bfa;
      --accent: #f43f5e;
      --line: #1f2937;
      --sudoku: #3b82f6;
      --hint: #f59e0b;
      --ok: #34d399;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Segoe UI', Inter, Roboto, sans-serif;
      background: radial-gradient(circle at 20% -10%, #0b2440 0%, var(--bg) 50%);
      color: var(--ink);
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: none;
      user-select: none;
      overflow: hidden;
    }

    .header {
      width: min(98vw, 520px);
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      align-items: stretch;
    }

    .score-display {
      background: linear-gradient(145deg, rgba(17, 24, 39, 0.9), rgba(2, 6, 23, 0.95));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 9px 12px;
      text-align: center;
      box-shadow: 0 0 18px rgba(34, 211, 238, 0.1);
    }

    .val { display: block; font-size: 24px; font-weight: 900; color: var(--primary); }
    .lbl { font-size: 10px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.75; }

    .status {
      width: min(98vw, 520px);
      margin: 8px 0 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }

    #hint-status {
      font-size: 13px;
      color: #cbd5e1;
      min-height: 1em;
    }

    .btn {
      border: 1px solid #334155;
      color: white;
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border-radius: 999px;
      padding: 8px 14px;
      font-weight: 700;
      cursor: pointer;
    }

    .btn:hover { border-color: var(--primary); }

    #board {
      display: grid;
      grid-template-columns: repeat(9, 40px);
      grid-template-rows: repeat(9, 40px);
      gap: 2px;
      background: var(--line);
      padding: 4px;
      border-radius: 10px;
      border: 2px solid #334155;
      position: relative;
    }

    .cell {
      width: 40px;
      height: 40px;
      background: #020617;
      border-radius: 4px;
      transition: transform .12s ease, background-color .18s ease, box-shadow .18s ease;
    }

    .cell[data-col="2"], .cell[data-col="5"] { border-right: 3px solid var(--sudoku); }
    .cell[data-row="2"], .cell[data-row="5"] { border-bottom: 3px solid var(--sudoku); }

    .cell.filled {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      box-shadow: inset 0 0 10px rgba(255,255,255,0.35);
    }
    .cell.ghost { background: rgba(34, 211, 238, 0.22); }
    .cell.hint { background: rgba(245, 158, 11, 0.32); box-shadow: 0 0 12px rgba(245, 158, 11, 0.42); }
    .cell.hint-ok { background: rgba(52, 211, 153, 0.26); box-shadow: 0 0 14px rgba(52, 211, 153, 0.4); }

    .tray {
      margin-top: 16px;
      width: min(98vw, 520px);
      display: flex;
      justify-content: center;
      gap: 10px;
      align-items: center;
      min-height: 125px;
    }

    .slot {
      width: 120px;
      height: 120px;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color .15s ease, transform .15s ease;
    }

    .slot.assist { border-color: var(--ok); box-shadow: 0 0 18px rgba(52, 211, 153, 0.18); }

    .mini-grid { display: grid; gap: 2px; }
    .mini-block {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      background: var(--primary);
      border: 1px solid rgba(255,255,255,0.18);
    }

    .floating-piece {
      position: fixed;
      pointer-events: none;
      display: grid;
      z-index: 9999;
      gap: 2px;
      filter: drop-shadow(0 0 18px rgba(34, 211, 238, 0.9));
    }

    .p-block {
      width: 40px;
      height: 40px;
      border-radius: 5px;
      background: linear-gradient(135deg, #67e8f9, #a78bfa);
      border: 1px solid rgba(255,255,255,0.25);
    }

    #game-over {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(0, 0, 0, 0.84);
      z-index: 10000;
    }

    .game-over-card {
      width: min(92vw, 420px);
      border-radius: 20px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: linear-gradient(160deg, rgba(15, 23, 42, 0.98), rgba(2, 6, 23, 0.98));
      box-shadow: 0 25px 45px rgba(0, 0, 0, 0.45);
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      text-align: center;
    }

    .game-over-title {
      font-size: clamp(34px, 8vw, 48px);
      color: var(--accent);
      margin: 0;
      line-height: 1;
      letter-spacing: 1px;
    }

    .game-over-subtitle {
      margin: 0;
      color: #cbd5e1;
      font-size: 14px;
      opacity: 0.95;
    }

    .game-over-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }

    .game-stat {
      border-radius: 12px;
      border: 1px solid rgba(100, 116, 139, 0.45);
      background: rgba(15, 23, 42, 0.82);
      padding: 10px 8px;
    }

    .game-stat strong {
      display: block;
      color: var(--primary);
      font-size: 22px;
      line-height: 1.1;
    }

    .game-stat span {
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.76;
    }

    .game-over-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .shake { animation: shake 0.35s cubic-bezier(.36,.07,.19,.97); }
    @keyframes shake { 20%,80% {transform:translateX(2px);} 30%,50%,70%{transform:translateX(-3px);} }
  </style>
</head>
<body>
  <div class="header">
    <div class="score-display"><span class="lbl">Récord</span><span class="val" id="high-score">0</span></div>
    <div class="score-display"><span class="lbl">Puntos</span><span class="val" id="score">0</span></div>
    <div class="score-display"><span class="lbl">Espacios</span><span class="val" id="free-cells">81</span></div>
  </div>

  <div class="status">
    <span id="hint-status">IA: analizando tablero…</span>
    <button class="btn" id="hint-btn">Sugerir jugada</button>
  </div>

  <div id="board"></div>

  <div class="tray">
    <div class="slot" id="slot-0"></div>
    <div class="slot" id="slot-1"></div>
    <div class="slot" id="slot-2"></div>
  </div>

  <div id="game-over">
    <div class="game-over-card">
      <h1 class="game-over-title">GAME OVER</h1>
      <p class="game-over-subtitle" id="game-over-subtitle">La IA ya está analizando una revancha.</p>
      <div class="game-over-stats">
        <div class="game-stat"><strong id="final-score">0</strong><span>Puntos</span></div>
        <div class="game-stat"><strong id="final-turns">0</strong><span>Turnos</span></div>
        <div class="game-stat"><strong id="final-clears">0</strong><span>Bloques limpiados</span></div>
      </div>
      <div class="game-over-actions">
        <button class="btn" id="retry-btn">Reintentar</button>
      </div>
    </div>
  </div>

  <script>
    const SHAPES = {
      dot:[[0,0]], h2:[[0,0],[0,1]], v2:[[0,0],[1,0]], h3:[[0,0],[0,1],[0,2]], v3:[[0,0],[1,0],[2,0]],
      h4:[[0,0],[0,1],[0,2],[0,3]], v4:[[0,0],[1,0],[2,0],[3,0]], h5:[[0,0],[0,1],[0,2],[0,3],[0,4]], v5:[[0,0],[1,0],[2,0],[3,0],[4,0]],
      sq2:[[0,0],[0,1],[1,0],[1,1]], sq3:[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],
      t_up:[[0,1],[1,0],[1,1],[1,2]], t_down:[[0,0],[0,1],[0,2],[1,1]], t_left:[[0,1],[1,0],[1,1],[2,1]], t_right:[[0,0],[1,0],[1,1],[2,0]],
      l1:[[0,0],[1,0],[2,0],[2,1]], l2:[[0,1],[1,1],[2,1],[2,0]], l3:[[0,0],[0,1],[1,0],[2,0]], l4:[[0,0],[0,1],[1,1],[2,1]],
      s1:[[0,1],[0,2],[1,0],[1,1]], z1:[[0,0],[0,1],[1,1],[1,2]],
      plus:[[0,1],[1,0],[1,1],[1,2],[2,1]], u_shape:[[0,0],[0,2],[1,0],[1,1],[1,2]],
      c_shape:[[0,0],[0,1],[1,0],[2,0],[2,1]], w_shape:[[0,0],[1,0],[1,1],[2,1],[2,2]],
      stairs:[[0,0],[1,0],[1,1],[2,1],[2,2]], big_l:[[0,0],[1,0],[2,0],[3,0],[3,1]],
      hook:[[0,0],[0,1],[1,0],[2,0],[3,0]], long_z:[[0,0],[0,1],[1,1],[2,1],[2,2]],
      corner3:[[0,0],[1,0],[1,1]], zig3:[[0,0],[0,1],[1,1]], tri_line:[[0,0],[1,0],[1,1]],
      frame:[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]], ring4:[[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]],
      snake6:[[0,0],[0,1],[1,1],[1,2],[2,2],[2,3]], bridge6:[[0,0],[1,0],[1,1],[1,2],[2,2],[3,2]]
    };

    const CATEGORIES = {
      RESCUE: ['dot','h2','v2','h3','v3','corner3','zig3','tri_line','sq2'],
      NORMAL: ['h4','v4','t_up','t_down','t_left','t_right','l1','l2','l3','l4','s1','z1','u_shape','plus'],
      HARD: ['h5','v5','sq3','c_shape','stairs','big_l','hook','long_z','w_shape','frame','ring4','snake6','bridge6']
    };

    const board = Array.from({length:9},()=>Array(9).fill(0));
    let score = 0;
    let highScore = Number(localStorage.getItem('blockudoku_high') || 0);
    let pieces = [null, null, null];
    let pieceMeta = [{assist:false},{assist:false},{assist:false}];
    let dragging = null;
    let dragEl = null;
    let turn = 0;
    let totalClears = 0;
    let assistCooldown = 0;
    let hintPulse = null;
    let gameEnded = false;

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high-score');
    const freeEl = document.getElementById('free-cells');
    const hintStatusEl = document.getElementById('hint-status');
    const gameOverEl = document.getElementById('game-over');
    highEl.textContent = highScore;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSfx(freq, type='sine', dur=0.13, vol=0.08) {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = vol;
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
      o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
    }

    function initBoard() {
      for (let r=0;r<9;r++) {
        for (let c=0;c<9;c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          boardEl.appendChild(cell);
        }
      }
    }

    function getFreeCells() { return board.flat().filter(v => v===0).length; }

    function randomFrom(list) { return list[Math.floor(Math.random()*list.length)]; }

    function allPlacements(shape) {
      const result = [];
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (canPlace(shape, r, c)) result.push({r,c});
      return result;
    }

    function canPlace(shape, r, c) {
      return shape.every(([dr,dc]) => {
        const nr = r+dr, nc = c+dc;
        return nr>=0 && nr<9 && nc>=0 && nc<9 && board[nr][nc]===0;
      });
    }

    function collectClears(simBoard) {
      const map = new Map();
      const push = (r,c)=>map.set(`${r},${c}`,{r,c});
      for (let i=0;i<9;i++) {
        if (simBoard[i].every(v=>v===1)) for (let c=0;c<9;c++) push(i,c);
        const col = Array.from({length:9},(_,r)=>simBoard[r][i]);
        if (col.every(v=>v===1)) for (let r=0;r<9;r++) push(r,i);
      }
      for (let sr=0;sr<9;sr+=3) for (let sc=0;sc<9;sc+=3) {
        const sec = [];
        for (let r=sr;r<sr+3;r++) for (let c=sc;c<sc+3;c++) sec.push({r,c});
        if (sec.every(p=>simBoard[p.r][p.c]===1)) sec.forEach(p=>push(p.r,p.c));
      }
      return [...map.values()];
    }

    function simulatePlacement(baseBoard, shape, r, c) {
      const sim = baseBoard.map(row => [...row]);
      shape.forEach(([dr,dc]) => sim[r+dr][c+dc] = 1);
      const clears = collectClears(sim);
      clears.forEach(({r:rr, c:cc}) => sim[rr][cc] = 0);
      return { sim, clears: clears.length };
    }

    function boardMetrics(simBoard) {
      const free = simBoard.flat().filter(v => v===0).length;
      const crowdedRows = simBoard.reduce((acc, row) => acc + (row.filter(v=>v===1).length >= 7 ? 1 : 0), 0);
      const crowdedCols = Array.from({length:9}, (_,c) => simBoard.map(r => r[c]).filter(v=>v===1).length)
        .reduce((acc, amount) => acc + (amount >= 7 ? 1 : 0), 0);
      return { free, pressure: crowdedRows + crowdedCols };
    }

    function evaluatePlacement(shape, r, c, idx) {
      const first = simulatePlacement(board, shape, r, c);
      const touchedRows = new Set(shape.map(([dr])=>r+dr)).size;
      const touchedCols = new Set(shape.map(([,dc])=>c+dc)).size;
      const firstMetrics = boardMetrics(first.sim);

      let followBest = -Infinity;
      let followMoves = 0;
      for (let j=0;j<3;j++) {
        if (j === idx || !pieces[j]) continue;
        const candidate = pieces[j];
        for (let rr=0;rr<9;rr++) {
          for (let cc=0;cc<9;cc++) {
            const can = candidate.every(([dr,dc]) => {
              const nr = rr + dr, nc = cc + dc;
              return nr>=0 && nr<9 && nc>=0 && nc<9 && first.sim[nr][nc]===0;
            });
            if (!can) continue;
            followMoves++;
            const second = simulatePlacement(first.sim, candidate, rr, cc);
            const secondMetrics = boardMetrics(second.sim);
            const secondScore = second.clears * 22 + secondMetrics.free * 0.26 - secondMetrics.pressure * 4.8;
            if (secondScore > followBest) followBest = secondScore;
          }
        }
      }
      if (!Number.isFinite(followBest)) followBest = -26;

      const rescueBonus = pieceMeta[idx]?.assist ? 8 : 0;
      return {
        value:
          shape.length * 8.5 +
          first.clears * 24 +
          touchedRows * 1.2 +
          touchedCols * 1.2 +
          firstMetrics.free * 0.35 -
          firstMetrics.pressure * 5.5 +
          followMoves * 0.85 +
          followBest * 0.45 +
          rescueBonus,
        firstClears: first.clears,
        followMoves
      };
    }

    function pickSpawnShape(slotIndex) {
      const free = getFreeCells();
      const dense = 81 - free;
      let pool = dense > 52 ? CATEGORIES.RESCUE : dense > 35 ? [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL] : [...CATEGORIES.NORMAL, ...CATEGORIES.HARD];
      let assist = false;

      const noMovesNow = pieces.filter(Boolean).every(shape => allPlacements(shape).length === 0);
      const danger = free <= 18 || noMovesNow;

      if (danger && assistCooldown <= 0) {
        const fittingRescue = CATEGORIES.RESCUE.filter(name => allPlacements(SHAPES[name]).length > 0);
        if (fittingRescue.length) {
          assist = true;
          assistCooldown = 2;
          return { shape: SHAPES[randomFrom(fittingRescue)], assist };
        }
      }

      for (let tries=0; tries<14; tries++) {
        const candidate = SHAPES[randomFrom(pool)];
        if (free > 20 || allPlacements(candidate).length > 0) return { shape: candidate, assist };
      }

      const guaranteed = [...CATEGORIES.RESCUE, ...CATEGORIES.NORMAL]
        .map(name => SHAPES[name])
        .find(shape => allPlacements(shape).length > 0);
      return { shape: guaranteed || SHAPES.dot, assist: guaranteed ? true : assist };
    }

    function spawnPieces() {
      for (let i=0;i<3;i++) {
        if (pieces[i]) continue;
        const pick = pickSpawnShape(i);
        pieces[i] = pick.shape;
        pieceMeta[i] = { assist: pick.assist };
      }
      assistCooldown = Math.max(assistCooldown - 1, 0);
      renderTray();
      autoHint(true);
    }

    function renderTray() {
      for (let i=0;i<3;i++) {
        const slot = document.getElementById(`slot-${i}`);
        slot.classList.toggle('assist', !!pieceMeta[i]?.assist);
        slot.innerHTML = '';
        if (!pieces[i]) continue;
        const shape = pieces[i];
        const rMax = Math.max(...shape.map(p=>p[0])) + 1;
        const cMax = Math.max(...shape.map(p=>p[1])) + 1;
        const g = document.createElement('div');
        g.className = 'mini-grid';
        g.style.gridTemplateRows = `repeat(${rMax},16px)`;
        g.style.gridTemplateColumns = `repeat(${cMax},16px)`;
        for (const [r,c] of shape) {
          const b = document.createElement('div');
          b.className = 'mini-block';
          b.style.gridRow = r+1;
          b.style.gridColumn = c+1;
          if (pieceMeta[i]?.assist) b.style.background = 'var(--ok)';
          g.appendChild(b);
        }
        slot.appendChild(g);
        slot.onpointerdown = e => startDrag(e, i);
      }
    }

    function startDrag(e, idx) {
      if (!pieces[idx]) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      dragging = { idx, shape: pieces[idx] };
      dragEl = document.createElement('div');
      dragEl.className = 'floating-piece';
      const shape = dragging.shape;
      const rMax = Math.max(...shape.map(p=>p[0])) + 1;
      const cMax = Math.max(...shape.map(p=>p[1])) + 1;
      dragEl.style.gridTemplateRows = `repeat(${rMax},40px)`;
      dragEl.style.gridTemplateColumns = `repeat(${cMax},40px)`;

      shape.forEach(([r,c]) => {
        const b = document.createElement('div');
        b.className = 'p-block';
        b.style.gridRow = r+1; b.style.gridColumn = c+1;
        dragEl.appendChild(b);
      });
      document.body.appendChild(dragEl);
      document.getElementById(`slot-${idx}`).style.opacity = 0.35;
      updateDragPos(e);
      playSfx(430, 'triangle', 0.1);
    }

    function getCellAt(x,y) {
      const el = document.elementFromPoint(x,y);
      if (el?.classList.contains('cell')) return { r: Number(el.dataset.row), c: Number(el.dataset.col) };
      return null;
    }

    function clearHighlights() {
      document.querySelectorAll('.cell.ghost,.cell.hint,.cell.hint-ok').forEach(c => c.classList.remove('ghost','hint','hint-ok'));
    }

    function updateDragPos(e) {
      if (!dragEl || !dragging) return;
      const x = e.clientX;
      const y = e.clientY - 110;
      dragEl.style.left = `${x - 20}px`;
      dragEl.style.top = `${y - 20}px`;
      clearHighlights();
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        dragging.shape.forEach(([dr,dc]) => {
          const c = document.querySelector(`.cell[data-row="${target.r+dr}"][data-col="${target.c+dc}"]`);
          c?.classList.add('ghost');
        });
      }
    }

    function checkAnyMovePossible() {
      return pieces.some(shape => !shape || allPlacements(shape).length > 0);
    }

    function clearAndScore() {
      const clearList = collectClears(board);
      if (!clearList.length) return 0;
      clearList.forEach(({r,c}) => board[r][c] = 0);
      score += clearList.length * 15;
      boardEl.classList.add('shake');
      setTimeout(()=>boardEl.classList.remove('shake'), 300);
      playSfx(940, 'square', 0.14); playSfx(1180, 'sine', 0.16);
      return clearList.length;
    }

    function placePiece(shape, r, c, idx) {
      if (gameEnded) return;
      shape.forEach(([dr,dc]) => board[r+dr][c+dc] = 1);
      score += shape.length * 10;
      totalClears += clearAndScore();
      pieces[idx] = null;
      pieceMeta[idx] = {assist:false};
      turn++;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('blockudoku_high', highScore);
      }
      if (pieces.every(p => !p)) spawnPieces();
      else renderTray();
      updateBoardUI();
      autoHint(false);
      if (!checkAnyMovePossible()) showGameOver();
      playSfx(620 + (score % 180), 'sine', 0.1);
    }

    function bestMoveSuggestion() {
      let best = null;
      for (let i=0;i<3;i++) {
        const shape = pieces[i];
        if (!shape) continue;
        for (const pos of allPlacements(shape)) {
          const prediction = evaluatePlacement(shape, pos.r, pos.c, i);
          if (!best || prediction.value > best.value) {
            best = { idx:i, shape, ...pos, ...prediction };
          }
        }
      }
      return best;
    }

    function applyHint(kind='hint') {
      const move = bestMoveSuggestion();
      clearHighlights();
      if (!move) {
        hintStatusEl.textContent = 'IA: no hay jugada posible con piezas actuales.';
        return;
      }
      move.shape.forEach(([dr,dc]) => {
        const cell = document.querySelector(`.cell[data-row="${move.r+dr}"][data-col="${move.c+dc}"]`);
        cell?.classList.add(kind === 'ok' ? 'hint-ok' : 'hint');
      });
      const cellsFree = getFreeCells();
      hintStatusEl.textContent = `IA: pieza ${move.idx + 1} en (${move.r + 1},${move.c + 1}) · clears:${move.firstClears} · futuro:${move.followMoves}`;
      if (hintPulse) clearTimeout(hintPulse);
      hintPulse = setTimeout(clearHighlights, 1700);
    }

    function autoHint(isSpawn) {
      const free = getFreeCells();
      const playableMoves = pieces.filter(Boolean).reduce((acc, shape) => acc + allPlacements(shape).length, 0);
      const shouldHelp = free <= 20 || playableMoves <= 6 || (isSpawn && free <= 26);
      hintStatusEl.textContent = shouldHelp
        ? 'IA: tablero crítico detectado, activando ayuda predictiva.'
        : `IA: estado estable · ${playableMoves} jugadas posibles.`;
      if (shouldHelp) applyHint('ok');
    }

    function updateBoardUI() {
      document.querySelectorAll('.cell').forEach(cell => {
        const filled = board[cell.dataset.row][cell.dataset.col] === 1;
        cell.classList.toggle('filled', filled);
      });
      scoreEl.textContent = score;
      highEl.textContent = highScore;
      freeEl.textContent = getFreeCells();
    }

    function showGameOver() {
      gameEnded = true;
      document.getElementById('final-score').textContent = score;
      document.getElementById('final-turns').textContent = turn;
      document.getElementById('final-clears').textContent = totalClears;
      const subtitle = score >= highScore
        ? 'Nuevo récord desbloqueado. ¡Muy buena partida!'
        : `Te faltaron ${highScore - score} puntos para el récord.`;
      document.getElementById('game-over-subtitle').textContent = subtitle;
      gameOverEl.style.display = 'flex';
      clearHighlights();
      if (hintPulse) clearTimeout(hintPulse);
    }

    function resetGame() {
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) board[r][c] = 0;
      score = 0;
      pieces = [null, null, null];
      pieceMeta = [{assist:false},{assist:false},{assist:false}];
      turn = 0;
      totalClears = 0;
      assistCooldown = 0;
      gameEnded = false;
      clearHighlights();
      gameOverEl.style.display = 'none';
      hintStatusEl.textContent = 'IA: analizando tablero…';
      spawnPieces();
      updateBoardUI();
    }

    window.onpointermove = updateDragPos;
    window.onpointerup = e => {
      if (gameEnded || !dragging) return;
      const x = e.clientX, y = e.clientY - 110;
      const target = getCellAt(x,y);
      if (target && canPlace(dragging.shape, target.r, target.c)) {
        placePiece(dragging.shape, target.r, target.c, dragging.idx);
      } else {
        document.getElementById(`slot-${dragging.idx}`).style.opacity = 1;
        playSfx(180, 'sawtooth', 0.1);
        autoHint(false);
      }
      clearHighlights();
      dragEl?.remove();
      dragEl = null;
      dragging = null;
      renderTray();
    };

    document.getElementById('hint-btn').addEventListener('click', () => applyHint('hint'));
    document.getElementById('retry-btn').addEventListener('click', resetGame);

    initBoard();
    spawnPieces();
    updateBoardUI();
  </script>
</body>
</html>
